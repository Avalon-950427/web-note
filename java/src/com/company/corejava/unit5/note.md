## 继承

多个类有相同属性和行为时,可以将这些内容抽取到单独一个类中,其他类就无须重复定义,继承那个类即可

```java
class Zi extends Fu{
}
```

Fu: 父类或者超类  
Zi: 子类或者派生类

低耦合:类与类的关系要少  
高内聚:类自己完成某件事情的能力要强

Java 继承的特点:只支持单继承,但支持多层继承

继承注意事项:

- 子类只能继承父类所有非私有成员(变量和方法)
- 子类不能继承父类的构造方法,但是可以通过 super 关键字去访问父类的构造方法
- 不要为了部分功能而去继承

什么时候使用继承:类 A 是类 B 的一种(如苹果是水果的一种),就可以使用继承

继承中成员变量的关系:

- 子类中成员变量父类中不一样,那么子类是子类的,父类是父类的
- 子类中成员变量和父类成员变量中不一样
  - 在子类方法的局部范围查找,有就使用
  - 在子类成员范围找,有就使用,
  - 在父类的成员范围找,有就使用

super 和 this 的区别

- this 代表本类对应的引用
- super 代表父类存储空间的标识

继承中构造方法的关系:

- 子类中所有的构造方法默认都回访问父类中无参构造方法
- 如果父类没有无参构造,且子类没有主动调用父类有参构造,会报错
- 为什么子类构造方法会访问父类构造方法?
  - 因为子类继承父类的数据,可能还会使用到,所有子类初始化之前,一定要先完成父类数据的初始化
  - 子类的构造方法的第一个语句默认是 super();

```java
class Fu{
    static{
        System.out.println("静态代码块Fu");
    }

    {
        System.out.println("构造代码块Fu");
    }

    public Fu(){
        System.out.println("构造方法Fu");
    }
}

class Zi{
    static{
        System.out.println("静态代码块Zi");
    }

    {
        System.out.println("构造代码块Zi");
    }

    public Zi(){
        System.out.println("构造方法Zi");
    }
}
class Test{
    public static void main(String[] args){
        Zi z = new Zi();
    }
}
/*
    执行顺序
    静态代码块Fu
    静态代码块Zi
    构造代码块Fu
    构造方法Fu
    构造代码块Zi
    构造方法Zi
*/
```

继承中成员方法的关系:

- 子类中的方法和父类中的方法声明不一样,那么子类是子类的,父类是父类的
- 子类中的方法和父类中的方法声明一样
  - 先找子类中有没有这个方法,有就使用
  - 再看父类中有没有这个方法,有就使用
  - 都没有则报错

方法重写:子类中出现了和父类中方法声明一模一样的方法  
当子类需要父类的功能,而功能主体子类有自己特有的内容可以重写父类的方法

方法重写的注意事项:

- 父类的私有方法不能被重写,因为父类的私有方法子类访问不到
- 子类重写父类方法时,权限不能更低
- 父类静态方法,子类也必须通过静态方法重写

final 的特点:

- final 修饰的类不能被继承
- final 修饰的方法,不能被子类重写
- final 修饰的变量,不能被重新赋值
- final 变量应该在构造方法结束前初始化

## 多态

某一个事物,在不同时刻表现出来的不同状态  
如:

- 猫是猫的类型:猫 m = new 猫()
- 猫是动物: 动物 m = new 猫()

多态的前提和体现:

- 有继承关系
- 有方法重写(多态就是靠方法重写来实现不同状态的)
- 要有父类引用指向子类对象`动物 m = new 猫()`

多态中的成员访问特点:

- 成员变量
  - 编译看左边,运行看左边
- 构造方法
  - 创建子类对象的时候,访问父类的构造方法,对父类的数据进行初始化
- 成员方法
  - 编译看左边,运行看右边
- 静态方法
  - 编译看左边,运行看左边

多态提高了程序的扩展性,但是多态创建出来的对象不能访问子类特有的方法,可用向下转型解决

- 向上转型: Fu f = new Zi();
- 向下转型: Zi z = (Zi)f;

ClassCastException:类型转换异常,多在多态中向下转型中出现

## 抽象类

1.在 java 中,一个没有方法体的方法应该定义为抽象方法,而类中如果有抽象方法,该类必须定义为抽象类

2.抽象类和抽象方法必须用 abstract 关键字修饰

```java
abstract class 类名{
    public abstract void 方法名();
}
```

3.抽象类有构造方法,但不能实例化,构造方法是用于子类访问父类数据的初始化 4.抽象类的子类如果不重写抽象方法,该子类是一个抽象类,重写了所有抽象方法,该子类是一个具体类

abstract 不能共存的关键字
关键字|原因
---|---
private|抽象方法需要重写,但是又是 private 就子类就访问不到了
final|final 不能修改,就不能被重写
static|抽象方法没有方法体,静态方法又能直接类名调用,调用一个没有方法体的方法没有意义

## 接口

只有部分事物才具有的功能可用接口来实现事物的扩展性,并不给出具体实现 1.接口用 interface 关键字表示

```java
interface 接口名{}
```

2.类实现接口用 implements 关键字

```java
class 类名 implements 接口名{}
```

3.接口是抽象的,不能被实例化,如要要实例化,只能用多态  
多态的方式:具体类多态,抽象类多态,接口多态  
4.接口的子类可以是抽象类,可以是具体类(需要重写方法)

接口中的成员特点:

- 成员变量:接口中的变量默认是静态常量,因为有默认修饰符 public static final
- 构造方法:接口没有构造方法
- 成员方法:只能是抽象方法,因为有默认修饰符 public abstract

接口与接口是继承关系,可以单继承也可以多继承`interface Sister extends Father,Mother`

## 抽象类名或接口名作为形式参数

本质就是一个多态,因为抽象类或接口作为形式参数,实参其实是一个具体子类

## 返回值类型

返回值类型是一个类,那么返回的是该类的一个对象
返回值类型是一个抽象类或者接口,那么返回的是继承该抽象类或实现该接口的类的对象

## 包

包就是文件夹,作用是对类进行分类管理(区分类名)

注意事项:

- package 语句必须是程序的第一条可执行代码
- package 语句在一个 java 文件中只能有一个
- 如果没有 package,默认表示无包名

导包`import 包名`,这种方式是导到类的名称

## 权限修饰符

| 空             | public | protected | 默认 | private |
| -------------- | ------ | --------- | ---- | ------- |
| 同一个类       | √      | √         | √    | √       |
| 同一个包       | √      | √         | √    |
| 不同包下子类   | √      | √         |      |         |
| 不同包下无关类 | √      |           |      |

## 内部类

内部类的特点:

- 内部类可以访问外部类的成员,包括私有
- 外部类要访问内部类的成员,需要创建内部类对象

访问成员内部类的成员:外部类名.内部类名 对象名 = 外部类对象.内部类对象

## 类超类和子类

#### 定义子类

extends 表明正在构造的新类派生于一个已存在的类  
通过扩展超类定义子类的时候,只需要指出子类和超类的不同之处

#### 方法重写

#### 子类构造器

子类构造器的第一句必须是通过 super()来调用父类的构造器,因为子类不能访问父类的私有字段,需要通过 super 关键字来初始化父类私有字段

this 的两个含义:

- 指示隐式参数的引用
- 调用该类的其他构造器(也是只能在构造器的第一条语句)

super 的两个含义:

- 调用超类的方法
- 调用超类的构造器

#### 继承层次

java 可以有多个继承层次

#### 多态

一个对象变量可以指示多种实际类型的现象叫做多态

是否继承可用 is-a 规则,它指出程序中出现超类对象的任何地方都可用子类对象替换`Employee e = new Manager()`  
但是 e 不能调用 Manager 中的方法`e.setBonus(5000)`,因为 e 是 Employee 类的引用,而 setBonus 是 Manager 类的方法
